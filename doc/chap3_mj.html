<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (QDistRnd) - Chapter 3: Description of the algorithm</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X7E421FAB7D974939" name="X7E421FAB7D974939"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X7E421FAB7D974939">3 <span class="Heading">Description of the algorithm</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7DDF42DF7D7F87EF">3.1 <span class="Heading">Elementary version</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7AE39C5583A02936">3.1-1 <span class="Heading">What it does?</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C198D417DA58DFD">3.1-2 <span class="Heading">The algorithm</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C37FBD078DDC0D5">3.1-3 <span class="Heading">Intuition</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7A291E1E7CD313AB">3.1-4 <span class="Heading">CSS version of the algorithm</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7D97C75283D26EE5">3.1-5 <span class="Heading">Generic version of the algorithm</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7DA7BD6F7A61E553">3.2 <span class="Heading">Some more details</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78810FD98017EB84">3.2-1 <span class="Heading">Quantum stabilizer codes</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C198D417DA58DFD">3.2-2 <span class="Heading">The algorithm</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7CCA4B9B834960EE">3.3 <span class="Heading">Empirical estimate of the success probability</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Description of the algorithm</span></h3>

<p><a id="X7DDF42DF7D7F87EF" name="X7DDF42DF7D7F87EF"></a></p>

<h4>3.1 <span class="Heading">Elementary version</span></h4>

<p><a id="X7AE39C5583A02936" name="X7AE39C5583A02936"></a></p>

<h5>3.1-1 <span class="Heading">What it does?</span></h5>

<p>In the simplest possible terms, we are given a pair of matrices <span class="SimpleMath">\(P\)</span> and <span class="SimpleMath">\(Q\)</span> with orthogonal rows, <span class="SimpleMath">\(PQ^T=0\)</span>. The matrices have entries in a finite field <span class="SimpleMath">\(F=GF(q)\)</span>, where <span class="SimpleMath">\(q\)</span> is a power of a prime. The goal is to find the smallest weight of a vector <span class="SimpleMath">\(c\)</span> over the same field <span class="SimpleMath">\(F\)</span>, such that <span class="SimpleMath">\(c\)</span> be orthogonal with the rows of <span class="SimpleMath">\(P\)</span>, <span class="SimpleMath">\(Pc^T=0\)</span>, and linearly independent from the rows of <span class="SimpleMath">\(Q\)</span>.</p>

<p><a id="X7C198D417DA58DFD" name="X7C198D417DA58DFD"></a></p>

<h5>3.1-2 <span class="Heading">The algorithm</span></h5>

<p>We first construct a generator matrix <span class="SimpleMath">\(G\)</span> whose rows form a basis of the <span class="SimpleMath">\(F\)</span>-linear space of all vectors orthogonal to the rows of <span class="SimpleMath">\(P\)</span>. At each step, a random permutation <span class="SimpleMath">\(S\)</span> is generated and applied to the columns of <span class="SimpleMath">\(G\)</span>. Then, Gauss' elimination with back substitution renders the resulting matrix to the reduced row echelon form, after which the inverse permutation <span class="SimpleMath">\(S^{-1}\)</span> is applied to the columns. Rows of the resulting matrix <span class="SimpleMath">\(G_S\)</span> that are linearly independent from the rows of <span class="SimpleMath">\(Q\)</span> are considered as candidates for the minimum weight vectors. Thus, after <span class="SimpleMath">\(N\)</span> steps, we are getting an upper bound on the distance which is improving with increasing <span class="SimpleMath">\(N\)</span>.</p>

<p><a id="X7C37FBD078DDC0D5" name="X7C37FBD078DDC0D5"></a></p>

<h5>3.1-3 <span class="Heading">Intuition</span></h5>

<p>The intuition is that each row of <span class="SimpleMath">\(G_S\)</span> is guaranteed to contain at least <code class="code">rank</code><span class="SimpleMath">\((G_S)-1\)</span> zeros. Thus, we are sampling mostly lower-weight vectors from the linear space orthogonal to the rows of <span class="SimpleMath">\(P\)</span>.</p>

<p><a id="X7A291E1E7CD313AB" name="X7A291E1E7CD313AB"></a></p>

<h5>3.1-4 <span class="Heading">CSS version of the algorithm</span></h5>

<p>The described version of the algorithm is implemented in the function <code class="code">DistRandCSS</code> <code class="func">DistRandCSS</code> (<a href="chap4_mj.html#X83CF58308216037F"><span class="RefLink">4.1-2</span></a>). It applies to the case of Calderbank-Shor-Steane (CSS) codes, where the matrices <span class="SimpleMath">\(P=H_X\)</span> and <span class="SimpleMath">\(Q=H_Z\)</span> are called the CSS generator matrices, and the computed minimum weight is the distance <span class="SimpleMath">\(d_Z\)</span> of the code. The number of columns <span class="SimpleMath">\(n\)</span> is the block length of the code, and it encodes <span class="SimpleMath">\(k\)</span> qudits, where <span class="SimpleMath">\(k=n-\)</span><code class="code">rank</code><span class="SimpleMath">\((H_X)-\)</span><code class="code">rank</code><span class="SimpleMath">\((H_Z)\)</span>. To completely characterize the code, we also need the distance <span class="SimpleMath">\(d_X\)</span> which can be obtained by calling the same function with the two matrices interchanged. The conventional code distance <span class="SimpleMath">\(d\)</span> is the minimum of <span class="SimpleMath">\(d_X\)</span> and <span class="SimpleMath">\(d_Z\)</span>. Parameters of such a <span class="SimpleMath">\(q\)</span>-ary CSS code are commonly denoted as <span class="SimpleMath">\([[n,k,(d_X,d_Z)]]_q\)</span>, or simply <span class="SimpleMath">\([[n,k,d]]_q\)</span> as for a general <span class="SimpleMath">\(q\)</span>-ary stabilizer code.</p>

<p><a id="X7D97C75283D26EE5" name="X7D97C75283D26EE5"></a></p>

<h5>3.1-5 <span class="Heading">Generic version of the algorithm</span></h5>

<p>CSS codes are a subclass of general <span class="SimpleMath">\(F\)</span>-linear stabilizer codes which are specified by a single stabilizer generator matrix <span class="SimpleMath">\(H=(A|B)\)</span> written in terms of two blocks of <span class="SimpleMath">\(n\)</span> columns each. The orthogonality condition is given in a symplectic form,</p>

<p class="center">\[ A B^T-B A^T=0, \]</p>

<p>or, equivalently, as orthogonality between the rows of <span class="SimpleMath">\(H\)</span> and the symplectic-dual matrix <span class="SimpleMath">\(\tilde H=(B|-A)\)</span>. Non-trivial vectors in the code must be orthogonal to the rows of <span class="SimpleMath">\(P=\tilde H\)</span> and linearly independent from the rows of <span class="SimpleMath">\(Q=H\)</span>. The difference with the CSS version of the algorithm is that we must minimize the <em>symplectic</em> weight of <span class="SimpleMath">\(c=(a|b)\)</span>, given by the number of positions <span class="SimpleMath">\(i\)</span>, <span class="SimpleMath">\(1\le i\le n\)</span>, such that either <span class="SimpleMath">\(a_i\)</span> or <span class="SimpleMath">\(b_i\)</span> (or both) be non-zero.</p>

<p>The parameters of such a code are denoted as <span class="SimpleMath">\([[n,k,d]]_q\)</span>, where <span class="SimpleMath">\(k=n-\)</span><code class="code">rank</code><span class="SimpleMath">\(H\)</span> is the number of encoded qudits, and <span class="SimpleMath">\(d\)</span> is the minimal symplectic weight of a non-trivial vector in the code. It is easy to check that a CSS code can also be represented in terms of a single stabilizer generator matrix. Namely, for a CSS code with generators <span class="SimpleMath">\(H_X\)</span> and <span class="SimpleMath">\(H_Z\)</span>, the stabilizer generator matrix has a block-diagonal form, <span class="SimpleMath">\(H=\)</span><code class="code">diag</code><span class="SimpleMath">\((H_X,H_Z)\)</span>.</p>

<p>A version of the algorithm for general <span class="SimpleMath">\(F\)</span>-linear stabilizer codes is implemented in the function <code class="code">DistRandStab</code> <code class="func">DistRandStab</code> (<a href="chap4_mj.html#X7894F0027B144AB8"><span class="RefLink">4.1-3</span></a>).</p>

<p><em>Important Notice</em>: In general, here one could use most general permutations of <span class="SimpleMath">\(2n\)</span> columns, or restricted permutations of <span class="SimpleMath">\(n\)</span> two-column blocks preserving the pair structure of the matrix. While the latter method would be much faster, there is no guarantee that every vector would be found. As a result, we decided to use general permutations of <span class="SimpleMath">\(2n\)</span> columns.</p>

<p><a id="X7DA7BD6F7A61E553" name="X7DA7BD6F7A61E553"></a></p>

<h4>3.2 <span class="Heading">Some more details</span></h4>

<p><a id="X78810FD98017EB84" name="X78810FD98017EB84"></a></p>

<h5>3.2-1 <span class="Heading">Quantum stabilizer codes</span></h5>

<p>Representation of quantum codes in terms of linear spaces is just a convenient map. In the case <span class="SimpleMath">\(q=2\)</span> (qubits), the details can be found, e.g., in the book of Nielsen and Chuang, <a href="chapBib_mj.html#biBNielsen-book">[NC00]</a>. Further details on the theory of stabilizer quantum error correcting codes based on qubits can be found in the Caltech Ph.D. thesis of Daniel Gottesman <a href="chapBib_mj.html#biBgottesman-thesis">[Got97]</a> and in the definitive 1997 paper by Calderbank, Rains, Shor, and Sloane <a href="chapBib_mj.html#biBCalderbank-1997">[CRSS98]</a>. Theory of stabilizer quantum codes based on qudits (<span class="SimpleMath">\(q\)</span>-state quantum systems) was developed by Ashikhmin and Knill <a href="chapBib_mj.html#biBAshikhmin-Knill-2001">[AK01]</a> (prime fields with <span class="SimpleMath">\(q\)</span> prime) and by Ketkar, Klappenecker, Kumar, &amp; Sarvepalli <a href="chapBib_mj.html#biBKetkar-Klappenecker-Kumar-Sarvepalli-2006">[KKKS06]</a> (extension fields with <span class="SimpleMath">\(q\)</span> a non-trivial power of a prime).</p>

<p>In the binary case (more generally, when <span class="SimpleMath">\(q\)</span> is a prime), <span class="SimpleMath">\(F\)</span>-linear codes coincide with <em>additive</em> codes. The <em>linear</em> codes [e.g., over <span class="SimpleMath">\(GF(4)\)</span> in the binary case <a href="chapBib_mj.html#biBCalderbank-1997">[CRSS98]</a>] is a different construction which assumes an additional symmetry. A brief summary of <span class="SimpleMath">\(F\)</span>-linear quantum codes [where <span class="SimpleMath">\(F=GF(q)\)</span> with <span class="SimpleMath">\(q=p^m\)</span>, <span class="SimpleMath">\(m&gt;1\)</span> a non-trivial power of a prime] can be found in the introduction of Ref. <a href="chapBib_mj.html#biBZeng-Pryadko-hprod-2020">[ZP20]</a>. The construction is equivalent to a more physical approach in terms of a lifted Pauli group suggested by Gottesman <a href="chapBib_mj.html#biBGottesman-prime-power-2014">[Got14]</a>.</p>

<p><a id="X7C198D417DA58DFD" name="X7C198D417DA58DFD"></a></p>

<h5>3.2-2 <span class="Heading">The algorithm</span></h5>

<p>Case of <em>classical linear codes</em></p>

<p>The algorithm <a href="chap3_mj.html#X7C198D417DA58DFD"><span class="RefLink">3.1-2</span></a> is closely related to the algorithm for finding minimum-weight codewords in a classical linear code as presented by Leon <a href="chapBib_mj.html#biBLeon-1988">[Leo88]</a>, and a related family of <em>information set</em> (IS) decoding algorithms <a href="chapBib_mj.html#biBKruk-1989">[Kru89]</a> <a href="chapBib_mj.html#biBCoffey-Goodman-1990">[CG90]</a>.</p>

<p>Consider a classical linear <span class="SimpleMath">\(q\)</span>-ary code <span class="SimpleMath">\([n,k,d]_q\)</span> encoding <span class="SimpleMath">\(k\)</span> symbols into <span class="SimpleMath">\(n\)</span>, specified by a generator matrix <span class="SimpleMath">\(G\)</span> of rank <span class="SimpleMath">\(k\)</span>. Using Gauss' algorithm and column permutations, the generator matrix can be rendered into a <em>systematic form</em>, <span class="SimpleMath">\(G=(I|A)\)</span>, where the two blocks are <span class="SimpleMath">\(I\)</span>, the size-<span class="SimpleMath">\(k\)</span> identity matrix, and a <span class="SimpleMath">\(k\)</span> by <span class="SimpleMath">\(n-k\)</span> matrix <span class="SimpleMath">\(A\)</span>. In such a representation, the first <span class="SimpleMath">\(k\)</span> positions are called the information set of the code (since the corresponding symbols are transmitted directly) and the remaining <span class="SimpleMath">\(n-k\)</span> symbols provide the redundancy. Any <span class="SimpleMath">\(k\)</span> linearly-independent columns of <span class="SimpleMath">\(G\)</span> can be chosen as the information set, which defines the systematic form of <span class="SimpleMath">\(G\)</span> up to a permutation of the rows of <span class="SimpleMath">\(A\)</span>.</p>

<p>The IS algorithm and the original performance bounds <a href="chapBib_mj.html#biBLeon-1988">[Leo88]</a> <a href="chapBib_mj.html#biBKruk-1989">[Kru89]</a> <a href="chapBib_mj.html#biBCoffey-Goodman-1990">[CG90]</a> are based on the observation that for a long random code a set of <span class="SimpleMath">\(k+\Delta\)</span> randomly selected columns, with <span class="SimpleMath">\(\Delta\)</span> of order one, are likely to contain an information set. ISs are (approximately) in one-to-one correspondence with the column permutations, and a random IS can thus be generated as a set of <em>pivot</em> columns in the Gauss' algorithm after a random column permutation. Thus, if there is a codeword <span class="SimpleMath">\(c\)</span> of weight <span class="SimpleMath">\(d\)</span>, the probability to find it among the rows of reduced-row-echelon form <span class="SimpleMath">\(G_S\)</span> after a column permutation <span class="SimpleMath">\(S\)</span> can be estimated as that for a randomly selected set of <span class="SimpleMath">\(k\)</span> columns to hit exactly one non-zero position in <span class="SimpleMath">\(c\)</span>.</p>

<p>The statistics of ISs is more complicated in other ensembles of random codes, e.g., in linear <em>low-density parity-check</em> (LDPC) codes where the check matrix <span class="SimpleMath">\(H\)</span> (of rank <span class="SimpleMath">\(n-k\)</span> and with rows orthogonal to those of <span class="SimpleMath">\(G\)</span>) is additionally required to be sparse. Nevertheless, a provable bound can be obtained for a related <em>covering set</em> (CS) algorithm where a randomly selected set of <span class="SimpleMath">\(s\ge k-1\)</span> positions of a putative codeword are set to be zero, and the remaining positions are constructed with the help of linear algebra. In this case, the optimal choice <a href="chapBib_mj.html#biBDumer-Kovalev-Pryadko-IEEE-2017">[DKP17]</a> is to take <span class="SimpleMath">\(s\approx n(1-\theta)\)</span>, where <span class="SimpleMath">\(\theta \)</span> is the erasure threshold of the family of the codes under consideration. Since <span class="SimpleMath">\(\theta\ge R\)</span> (here <span class="SimpleMath">\(R=k/n\)</span> is the code rate), here more zeros must be selected, and the complexity would grow (assuming the distance <span class="SimpleMath">\(d\)</span> remains the same, which is usually <em>not</em> the case for LDPC codes).</p>

<p>Note however that rows of <span class="SimpleMath">\(G_P\)</span> other than the last are not expected to contain as many zeros (e.g., the first row is only guaranteed to have <span class="SimpleMath">\(k-1\)</span> zeros), so it is <em>possible</em> that the performance of the IS algorithm on LDPC codes is actually closer to that on random codes as estimated by Leon <a href="chapBib_mj.html#biBLeon-1988">[Leo88]</a>.</p>

<p>Case of <em>quantum CSS codes</em></p>

<p>In the case of a random CSS code (with matrices <span class="SimpleMath">\(P\)</span> and <span class="SimpleMath">\(Q\)</span> selected randomly, with the only requirement being the orthogonality between the rows of <span class="SimpleMath">\(P\)</span> and <span class="SimpleMath">\(Q\)</span>), the performance of the algorithm <a href="chap3_mj.html#X7C198D417DA58DFD"><span class="RefLink">3.1-2</span></a> can be estimated as that of the CS algorithm, in terms of the erasure threshold of a linear code with the parity matrix <span class="SimpleMath">\(P\)</span>, see <a href="chapBib_mj.html#biBDumer-Kovalev-Pryadko-IEEE-2017">[DKP17]</a>.</p>

<p>Unfortunately, such an estimate fails dramatically in the case of <em>quantum LDPC codes</em>, where rows of <span class="SimpleMath">\(P\)</span> and <span class="SimpleMath">\(Q\)</span> have weights bounded by some constant <span class="SimpleMath">\(w\)</span>. This is a reasonable requirement since the corresponding quantum operators (supported on <span class="SimpleMath">\(w\)</span> qudits) have to actually be measured frequently as a part of the operation of the code, and it is reasonable to expect that the measurement accuracy goes down (exponentially) quickly as <span class="SimpleMath">\(w\)</span> is increased. Then, the linear code orthogonal to the rows of <span class="SimpleMath">\(P\)</span> has the distance <span class="SimpleMath">\(\le w\)</span> (the minimal weight of the rows of <span class="SimpleMath">\(Q\)</span>), and the corresponding erasure threshold is exactly zero. In other words, there is a finite probability that a randomly selected <span class="SimpleMath">\(w\)</span> symbols contain a vector orthogonal to the rows of <span class="SimpleMath">\(P\)</span> (and such a vector would likely have nothing to do with non-trivial <em>quantum</em> codewords which must be linearly independent from the rows of <span class="SimpleMath">\(Q\)</span>).</p>

<p>On the other hand, for every permutation <span class="SimpleMath">\(S\)</span> in the algorithm <a href="chap3_mj.html#X7C198D417DA58DFD"><span class="RefLink">3.1-2</span></a>, the matrix <span class="SimpleMath">\(G_S\)</span> contains exactly <span class="SimpleMath">\(k=n-\)</span><code class="code">rank</code><span class="SimpleMath">\((P)-\)</span><code class="code">rank</code><span class="SimpleMath">\((Q)\)</span> rows orthogonal to rows of <span class="SimpleMath">\(P\)</span> and linearly independent from rows of <span class="SimpleMath">\(Q\)</span> (with columns properly permuted). These vectors contain at least <span class="SimpleMath">\(s\)</span> zeros, where <span class="SimpleMath">\([1-\theta_*(P,Q)] n\le s\le n-\)</span><code class="code">rank</code><span class="SimpleMath">\((Q)\)</span>, where <span class="SimpleMath">\(\theta_*(P,Q)\)</span> is the erasure threshold for <span class="SimpleMath">\(Z\)</span>-like codewords in the quantum CSS code with <span class="SimpleMath">\(H_X=P\)</span> and <span class="SimpleMath">\(H_Z=Q\)</span>.</p>

<p><em>What is it that we do not understand?</em></p>

<p>What missing is an understanding of the statistics of the ISs of interest, namely, the ISs that overlap with a minimum-weight codeword in one (or a few) positions.</p>

<p>Second, we know that a given column permutation <span class="SimpleMath">\(S\)</span> leads to the unique information set, and that every information set can be obtained by a suitably chosen column permutation. However, there is no guarantee that the resulting information sets have equal probabilities. In fact, it is easy to construct small matrices where different information sets are obtained from different numbers of column permutations (and thus have different probabilities). It is not clear whether some of the ISs may have vanishingly small probabilities in the limit of large codes; in such a case the algorithm would fail.</p>

<p><a id="X7CCA4B9B834960EE" name="X7CCA4B9B834960EE"></a></p>

<h4>3.3 <span class="Heading">Empirical estimate of the success probability</span></h4>

<p>The probability to find a codeword after <span class="SimpleMath">\(N\)</span> rounds of the algorithm can be estimated empirically, by counting the number of times each codeword of the minimum weight was discovered. We <em>expect</em> the probability <span class="SimpleMath">\(P(c)\)</span> to discover a given codeword <span class="SimpleMath">\(c\)</span> to depend only on its (symplectic) weight <code class="code">wgt</code><span class="SimpleMath">\((c)\)</span>, with the probability a monotonously decreasing function of the weight. If, after <span class="SimpleMath">\(N\)</span> steps, codewords <span class="SimpleMath">\(c_1\)</span>, <span class="SimpleMath">\(c_2\)</span>, <span class="SimpleMath">\(\ldots\)</span> , <span class="SimpleMath">\(c_m\)</span> of the same (minimal) weight <span class="SimpleMath">\(w\)</span> are discovered <span class="SimpleMath">\(n_1\)</span>, <span class="SimpleMath">\(n_2\)</span>, <span class="SimpleMath">\(\ldots\)</span> , <span class="SimpleMath">\(n_m\)</span> times, respectively, we can estimate the corresponding Poisson parameter as</p>

<p class="center">\[ \lambda_w =\frac{1}{N m}\sum_{i=1}^m n_i. \]</p>

<p>Then, the probability that a codeword <span class="SimpleMath">\(c_0\)</span> of the true minimal weight <span class="SimpleMath">\( d &lt; w \)</span> be <em>not</em> discovered after <span class="SimpleMath">\(N\)</span> steps can be upper bounded as (the inequalities here become equalities in the limit of small <span class="SimpleMath">\(\lambda_w\)</span>)</p>

<p class="center">\[ P_{\rm fail} &lt; (1-\lambda_w)^N &lt;
e^{-N\lambda_w}=\exp\left(-m^{-1}\sum_{i=1}^m n_i\right)\equiv
\exp(-\langle n\rangle).
\]</p>

<p>Thus, the probability to fail is decreasing as an exponent of the parameter <span class="SimpleMath">\(\langle n\rangle\)</span>, the <em>average number of times a minimum-weight codeword has been found.</em></p>

<p>The hypothesis about all <span class="SimpleMath">\(P(c_i)\)</span> being equal to <span class="SimpleMath">\(\lambda_w\)</span> is testable, e.g., if one considers the distribution of the ratios <span class="SimpleMath">\(x_i=n_i/N\)</span>, where <span class="SimpleMath">\(N=\sum_{i=1}^m n_i\)</span> is the total number of codewords found. These quantities sum up to one and are distributed according to multinomial distribution<a href="chapBib_mj.html#biBSteel-1953">[Ste53]</a>. Further, under our assumption of all <span class="SimpleMath">\(P(c_i)\)</span> being equal, we also expect the outcome probabilities in the multinomial distribution to be all equal, <span class="SimpleMath">\(\pi_i=1/m\)</span>, <span class="SimpleMath">\(1\le i\le m\)</span>.</p>

<p>This hypothesis can be tested using Pearson's <span class="SimpleMath">\(\chi^2\)</span> test. Namely, in the limit where the total number of observations <span class="SimpleMath">\(N\)</span> diverges, the quantity</p>

<p class="center">\[ X^2=\sum_{i=1}^m \frac{(n_i-N \pi_i)^2}{ N\pi_i}=
N^{-1}\sum_{i=1}^m \frac{n_i^2}{\pi_i}-N
\stackrel{\pi_i=1/m}\to\frac{m}{N}\sum_{i=1}^m n_i^2-N, \]</p>

<p>is expected to be distributed according to the <span class="SimpleMath">\(\chi^2_{m-1}\)</span> distribution with <span class="SimpleMath">\(m-1\)</span> parameters, see <a href="chapBib_mj.html#biBChernoff-Lehmann-1954">[CL54]</a> <a href="chapBib_mj.html#biBCramer-book-1999">[Cra99]</a>.</p>

<p>In practice, we can approximate with the <span class="SimpleMath">\(\chi^2_{m-1}\)</span> distribution as long as the total <span class="SimpleMath">\(N\)</span> be large compared to the number <span class="SimpleMath">\(m\)</span> of the codewords found (i.e., the average <span class="SimpleMath">\(\langle n\rangle\)</span> must be large, which is the same condition as needed for confidence in the result.)</p>

<p>With <code class="code">debug[4]</code> set (binary value 8) in <code class="code">DistRandCSS</code> and <code class="code">DistRandStab</code> <a href="chap4_mj.html#X826856C47F9890F3"><span class="RefLink">4.1</span></a>, whenever more than one minimum-weight vector is found, the quantity <span class="SimpleMath">\(X^2\)</span> is computed and output along with the average number of times <span class="SimpleMath">\(\langle n\rangle\)</span> a minimum-weight codeword has been found. However, no attempt is made to analyze the corresponding value or calculate the likelihood of the null hypothesis that the codewords be equiprobable.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
